// ==UserScript==
// @name         GeoFS Airport Models Loader (JSON fixed)
// @namespace    geofs-custom-airport-loader
// @version      1.3.1
// @description  Load glTF (.glb) airport models into GeoFS from JSON
// @match        https://www.geo-fs.com/*
// @run-at       document-end
// @author       geofslike-wq
// ==/UserScript==

(function () {
  "use strict";

  /* ================= è¨­å®š ================= */

  // â˜… æ­£ã—ã„ Raw JSON URLï¼ˆå…ˆé ­ãƒã‚¤ãƒ•ãƒ³æ³¨æ„ï¼‰
  const JSON_URL =
    "https://raw.githubusercontent.com/geofslike-wq/-GeoFS-OSM-Airport-Models/main/airportdata.json";

  const BOOT_DELAY_MS = 1500;
  const CHECK_INTERVAL_MS = 500;

  const DEFAULT_MODEL_OPTIONS = {
    minimumPixelSize: 128,
    maximumScale: 2000
  };

  /* ======================================== */

  function isReady() {
    return (
      typeof geofs !== "undefined" &&
      geofs.api &&
      geofs.api.viewer &&
      typeof Cesium !== "undefined"
    );
  }

  async function fetchJson(url) {
    const res = await fetch(url, { cache: "no-cache" });
    if (!res.ok) {
      throw new Error(`JSON fetch failed: HTTP ${res.status}`);
    }
    return res.json();
  }

  function alreadyExists(id) {
    return geofs.api.viewer.entities.values.some(e => e.name === id);
  }

  function addModel(raw) {
    const entry = {
      name: raw.name || raw.url,
      url: raw.url,
      lon: Number(raw.lon),
      lat: Number(raw.lat),
      alt: Number(raw.alt) || 0,
      heading: Number(raw.heading) || 0,
      pitch: Number(raw.pitch) || 0,
      roll: Number(raw.roll) || 0,
      scale: Number(raw.scale) || 1.0
    };

    if (!entry.url || isNaN(entry.lon) || isNaN(entry.lat)) {
      console.error("âŒ Invalid model entry:", raw);
      return;
    }

    if (alreadyExists(entry.name)) {
      console.log("â­ already loaded:", entry.name);
      return;
    }

    const position = Cesium.Cartesian3.fromDegrees(
      entry.lon,
      entry.lat,
      entry.alt
    );

    const hpr = new Cesium.HeadingPitchRoll(
      Cesium.Math.toRadians(entry.heading),
      Cesium.Math.toRadians(entry.pitch),
      Cesium.Math.toRadians(entry.roll)
    );

    const orientation =
      Cesium.Transforms.headingPitchRollQuaternion(position, hpr);

    geofs.api.viewer.entities.add({
      name: entry.name,
      position,
      orientation,
      model: {
        uri: entry.url,
        scale: entry.scale,
        minimumPixelSize: DEFAULT_MODEL_OPTIONS.minimumPixelSize,
        maximumScale: DEFAULT_MODEL_OPTIONS.maximumScale
      }
    });

    console.log(
      `âœ… Loaded ${entry.name}`,
      `scale=${entry.scale}`,
      `alt=${entry.alt}`
    );
  }

  async function loadAll() {
    try {
      console.log("ðŸ“¦ Fetching airportdata.json");
      const data = await fetchJson(JSON_URL);

      if (!Array.isArray(data)) {
        console.error("âŒ JSON is not an array:", data);
        return;
      }

      console.log(`ðŸ“¦ ${data.length} models found`);
      data.forEach(addModel);

    } catch (e) {
      console.error("ðŸ”¥ Airport loader failed:", e);
    }
  }

  function boot() {
    const timer = setInterval(() => {
      if (isReady()) {
        clearInterval(timer);
        console.log("ðŸŸ¢ GeoFS ready, loading models...");
        setTimeout(loadAll, BOOT_DELAY_MS);
      }
    }, CHECK_INTERVAL_MS);
  }

  boot();
})();
